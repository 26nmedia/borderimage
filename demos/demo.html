<!DOCTYPE html>	
<html>
<head>
	<title>border-image demonstration page</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=7" />
	<link media="screen" type="text/css" href="style.css" rel="stylesheet" />
	<style type="text/css">
		.button a {
			border: solid transparent;
			border-width: 0 8px;
		}		
		.button a:focus {
			outline: none;
		}				
		.button a .biSlice {
			z-index: -1;
		}
		.button a .image0 {
			z-index: 0;
		}
		.button a {
			-moz-border-image: url("media/button0.png") 0 5;
			-webkit-border-image: url("media/button0.png") 0 5;
		}
		.button a.bi1 .image1 {
			z-index: 0;
		}
		.button a.bi1 {
			-moz-border-image: url("media/button1.png") 0 5;
			-webkit-border-image: url("media/butto1.png") 0 5;
		}	
		.button a.bi2 .image2 {
			z-index: 0;
		}
		.button a.bi2 {
			-moz-border-image: url("media/button2.png") 0 5;
			-webkit-border-image: url("media/button2.png") 0 5;
		}
	</style>	
</head>
<body>
<div id="header">
	<h1>Meet a ninja living in browsers</h1>
	<p><a href="http://www.w3.org/Style/CSS/current-work#CSS3">CSS3 draft</a> introduces, amongst many properties
	that will change a Web designer's life, one that could be terribly powerful: <a href="http://www.w3.org/TR/css3-background/#the-border-image">border-image</a>.<br />
	Discover what it can do today.</p>
	
</div>
<div class="float">
	<div id="logo"><img src="media/logo.png" alt="logo of borderImage: a ninja slicing an image" style="width:100%" /></div>
	<div id="sidebar">
		<p>
			In the dark ages of table layouts, Web pioneers used to build their
			whole pages using heavy, unmaintainable, inaccessible
			&lt;table&gt;s.
		</p>
		<p>
			Then came CSS with the simple promise of
			<em>Allowing a clear separation between the content and the presentation</em>.
			But it failed to save them from slicing images with their precious hands
			and countless, meaningless &lt;div&gt;s, just to create visually pleasing designs.
		</p>
		<p>
			Introducing CSS3 and the border-image property, your personal design ninja.
			It is now possible to decorate any container or element of a page
			independently of its position and dimensions in a flash.
			Just design and describe how you would've sliced;
			sit back and let a ninja do the dirty work.
		</p>
		<p class="center">
			<a href="http://creativecommons.org/licenses/by-sa/2.0/fr/deed.fr" rel="license">
				<img src="http://i.creativecommons.org/l/by-sa/2.0/fr/88x31.png" alt="Creative Commons License"  style="border-width:0;"/>
			</a>
		</p>
	</div>
</div>

<div id="main">
	<ul id="nav">
		<li class="selected"><a href="#css3">The CSS property</a></li>
		<li><a href="#script">The script</a></li>
		<li><a href="#images">Base images</a></li>
		<li><a href="#advanced">Advanced use</a></li>
	</ul>
<div class="tab" id="css3">
	<h2 class="first">Learn its code</h2>
	<p>Let's start with a simple example to see how the border-image ninja can be invoked and given instructions:</p>
<pre><code>#element {
    border-width: 10px 15px 12px 13px;
    border-image: url("border.png") 30% 35% 40% 30% round round;
}</code></pre>
	<p>
		The first property obviously describes one element's borders as usual: 
		the widths of the four borders are expressed in pixels, <strong>clockwise</strong> 
		(<i>border-top</i>, <i>border-right</i>, <i>border-bottom</i>, <i>border-left</i>).
	</p>
	<span class="center"><img src="media/clock.png" alt="clock"></span>
	<p>
		Needless to say that, using this syntax:
	</p>
	<ul>
		<li>when omitting to specify the <i>border-left</i> width, the browser uses the <i>border-right</i> value,</li>
		<li>when omitting the <i>border-bottom</i> value it uses the <i>border-top</i> value,</li>
		<li>when specifying only one value, it will be used for the four borders.</li>
	</ul>
<pre class="float" style="margin-top: 0;"><code>#element {
    border-width: 12px 12px;
    /* Is equivalent to */
    border-width: 12px;
}</code></pre>
<pre><code>#element {
    border-width: 10px 15px 10px 15px;
    /* Is equivalent to */
    border-width: 10px 15px;
}</code></pre>
	<p>
		The same principles will apply to the second part of the next property.
	</p>
	<p>
		The second property is the one which will actually invoke our zealous ninja.
		There are usually three parts in a border-image property (although if you read the specification carefully, you will
		find a fourth one, which would only be confusing at this point):
	</p>
	<ol>
		<li>
			<pre><code>url("border.png")</code></pre>
			This part indicates the location of the image that will be sliced to decorate our element. 
			Nothing really original here, the background-image uses the same syntax. And this is our image:
			<span class="center"><img src="media/border.png" alt="the image that we are gonna slice"></span>
		</li>
		<li>
			<pre><code>30% 35% 40% 30%</code></pre>
			The second part describes the way our ninja will slice the image into nine parts (<i>slices</i>):
			<span class="center">
				<img src="media/sliceHere.png" alt="instructions for our ninja to cut the image"><br/>
				<i>Guess what will happen to this poor image... (hint: ninjas are merciless).</i><br/>
			</span>
			Those values can be expressed either in percentages
			or without any unit to slice an exact width of pixels from the image.
		</li>		
		<li>
			<pre><code>round round</code></pre>
			The last part is the <i>stretch value</i>.
			It describes how the slices for the sides and the middle part are scaled and tiled.
			A few things to remember:
			<ul>
				<li>specifying only one value is the same as specifying twice the same one,</li>
				<li>there are three possible values: "<i>stretch</i>", "<i>repeat</i>" and "<i>round</i>",</li>
				<li>the default value is "<i>stretch</i>".</li>
			</ul>					 
		</li>
	</ol>
	<p id="innaccessible" style="display:none;">
		This is the most complex part of the specification, so it deserves an interactive demonstration:
	</p>			
	<div id="demonstration" style="display:none;">
		<span class="center"><img src="media/diamonds.png" /></span>
<pre><code>div#demo {
    border: solid transparent;
    border-width: 20px 30px 25px 20px;
    border-image: url("diamonds.png") 33% <select><option value="">choose<option value="stretch">stretch<option value="repeat">repeat<option value="round">round</select>				
}</code></pre>
		<div id="container" style="position:relative;height:112px;width:138px;border: solid red; border-width:20px 30px 25px 20px;margin: 0 auto;">					
		</div>
	</div>
	<p>
		Curious developers willing to know what happens when using borders with null width, or when using two different "stretch" values,
		should read the <a href="http://www.w3.org/TR/css3-background/#the-border-image">original specification</a>.
	</p>
	<h2>See what it can do</h2>
	<p>
		You have the resources to be creative, imaginative and you certainly have an opinion about beauty. 
		The border-image ninja doesn't know anything about that, it is just really good at martial techniques; 
		it is only a tool allowing you to express yourself.
		Here is what it can do when asked for some purely technical demonstrations:
	</p>
	<h3>Rounded corners</h3>
	<div class="float right">
		<span style="color:white;">borderImage</span>
		<pre><code>border-width: 10px;</code></pre>
	</div>
	<div>
		<img src="media/roundedCorner.png" alt="a source image to slice">
		<pre><code class="demo">border-image: url("media/roundedCorner.png") 20;</code></pre>
	</div>
	<h3>Complex borders</h3>
	<div class="float right">
		<span>ninja!</span>
		<pre><code>border-width: 20px;</code></pre>
	</div>
	<div>
		<img src="media/border.png" alt="a source image to slice">
		<pre><code class="demo">border-image: url("media/border.png") 20;</code></pre>
	</div>
	<h3>Drop shadow</h3>
	<div class="float right">
		<span style="color: red;">wooooosh</span>
		<pre><code>border-width: 10px;</code></pre>
	</div>
	<div>
		<img src="media/blackShadow.png" alt="a source image to slice">
		<pre><code class="demo">border-image: url("media/blackShadow.png") 5;</code></pre>
	</div>
	<h3>Tab</h3>
	<div class="float right">
		<span style="color: white;">katanas</span>
		<pre><code>border-width: 15px 20px 0;</code></pre>
	</div>
	<div>
		<img src="media/tab.png" alt="a source image to slice">
		<pre><code class="demo">border-image: url("media/tab.png") 20 20 0;</code></pre>
	</div>
	<h3>Stretching background</h3>
	<div class="float center">
		<div style="color: white; width: 50px;">learn<br/>to be<br/><span style="color: #aaa;">lazy</span></div>
		<pre><code>border-width: 10px 10px 0;</code></pre>
	</div>
	<div>
		<img src="media/gradient.png" alt="a source image to slice">
		<pre><code class="demo">border-image: url("media/gradient.png") 10 10 0;</code></pre>
	</div>
	<h3>And even multi-state buttons</h3>
	<div class="float right">
		<span class="button"><a href="#nogo">hover & click</a></span>
		<pre><code>But not impossible.</code></pre>
	</div>
	<div>
		<img src="media/button0.png" alt="a source image to slice"> <img src="media/button1.png" alt="a source image to slice"> <img src="media/button2.png" alt="a source image to slice">
		<pre><code>This one is tricky.</code></pre>
	</div>
	<h2>Start using it today</h2>
	<p>
		Currently this property is only implemented in the upcoming Firefox3.1 and recent releases of Safari and Chrome.
		But most current browsers implement features that are able to slice images:
	</p>
	<ul>
		<li>The <a href="http://www.whatwg.org/specs/web-apps/current-work/#canvas">canvas element</a> and its <a href="http://www.whatwg.org/specs/web-apps/current-work/#dom-context-2d-drawimage">drawImage</a> method,
			available in firefox2+ and recent releases of opera browser.
		</li>
		<li>
			<a href="http://msdn.microsoft.com/en-us/library/bb263898(VS.85).aspx">VML</a>,
			its <a href="http://msdn.microsoft.com/en-us/library/bb229512(VS.85).aspx">image element</a> 
			and its <i>crop</i> properties available in ie6+.
		</li>
	</ul>
	<p>
		Those features could only be compared to a <a href="http://en.wikipedia.org/wiki/Katana">katana</a>. 
		A ninja still has to be created to use it and produce the same effect as border-image:
		create nine slices from the image one by one, and then tile them in the background of our element.
	</p>
	<span class="center"><img src="media/katanas.png" alt="four katanas slicing an image"></span>
	<p>
		There is such a ninja living in this very page: <a href="#script">jquery.borderImage.js</a>.
	</p>
	<h2>Limits of border-image</h2>
	<p>
		This property is not implemented in all browsers. 
		Although it is possible to emulate it, one can neither expect the same level of quality, performance nor
		conformity to the specification. 
		Moreover, it cannot be done without alterations to the DOM of Web pages:		
	</p>
	<ul>
		<li>Nine &lt;img&gt;s that will display the slices have to be inserted inside the element,</li>
		<li>the content of the element has to be wrapped and positioned to appear on top of the background slices,</li>
		<li>the element itself has to be positioned (in relative or absolute) for the slices to scale seamlessly with the element,</li>
		<li>elements displayed <i>inline</i> have to be switched to <i>inline-block</i> for the slices to be correctly tiled inside the element.</li>
	</ul>
	<p>
		Only the <i>stretch</i> keyword can be implemented.
		Supporting both <i>repeat</i> and <i>round</i> would involve creation of countless background &lt;img&gt;s
		(which is not reasonable for performance reasons),
		and it would be impossible to make them scale dynamically with the element.
	</p>
	<h2>A useful ninja for modern Web design</h2>
	<p>
		Nowadays, there are too many browsers available, too many operating systems being used (each one with its own set of fonts), 
		resulting in so many configurations that trying to create a cross-browser pixel-perfect Web design appears to be a dead end.
		You should rather consider building Web design using simple tools such as <i>border-image</i> that degrade gracefully
		in older browsers but always keep a clear separation between content and presentation, thus easing maintenance of your code.
	</p>
</div>
<div class="tab" id="script">
	<h2 class="first">A first implementation: jquery.borderImage.js</h2>
	<p>
		This page uses a script that is a partial implementation of border-image, 
		packaged as a plugin for the popular <a href="http://www.jquery.com">jQuery</a> library.
		Dependence on jQuery features has been kept minimal in order to ease reuse of the script with
		other popular libraries. Following is the kind of JavaScript code to write instead of using the css property:
	</p>
<pre><code>$('#element').borderImage('url("border.png") 30% 35% 40% 30%');</code></pre>
	<p>
		Depending on browser features, this script will either use native implementation of the CSS property,
		or try to use canvas or vml instead. 
		It is only a partial implementation of the property since only the <i>stretch</i> value is available, for reasons explained above.
		It works better on <i>block</i> or <i>inline-block</i> displayed elements;
		visual result is not guaranteed to be cross-browser on inline elements.
	</p>
	<h3 id="getCode">Get the code</h3>
	<p>
		The script is dual licensed under MIT and GPLv3 licenses and is available on <a href="http://github.com/lrbabe/borderimage/tree/master">github</a> for <a href="http://github.com/lrbabe/borderimage/raw/master/jquery.borderImage.js">download</a>.
	</p>
	<p>
		Everyone is encouraged to port this piece of code to his/her favorite JavaScript library 
		and to encourage other people to use it : )
		I will be happy to provide help with this: <a href="mailto:public@lrbabe.com">public@lrbabe.com</a>
	</p>
	<h3>Browsers compatibility</h3>
	<p>
		jquery.borderImage.js has been tested on the following browsers:
	<ul>
		<li>Firefox 2.*, Firefox 3, Firefox 3.1</li>
		<li>Safari 3.*</li>
		<li>Chrome 1.0</li>
		<li>Opera 9.*, Opera 10</li>
		<li>IE7</li>
	</ul>
	<p>
		There is still a bug on IE6 that prevents its use on large elements (more than 100px wide or tall)
		and there are some graphical glitches when using transparent/semi-transparent png images. 
		The way VML is handled in IE8 also changed a little bit and a fix is on its way to make the script
		compatible with this browser. In the mean time, the IE7 meta tag can be used:
	</p>
<pre><code>&lt;meta http-equiv="X-UA-Compatible" content="IE=7" /&gt;</code></pre>
	<h3>Resizing an element dynamically</h3>
	<p>
		When dynamically resizing an element, every slice but the edges are supposed to be scaled seamlessly.
		However, when using an animation (such as jQuery's <i>animate</i> function), 
		border slices temporarily disappear when resizing the element directly if border-image is emulated.
		One should rather resize the content of the element or use the provided helper function:
	</p>
<pre><code>$('#element').biResize({height: '200px', width: '300px'}, options);</code></pre>
	<p>
		Note that it is not possible to dynamically resize the borders' widths.
	</p>
	<!--<h3>Using stretching background</h3>
	<p>
		If you are using an image that will be obviously stretched with the border-image property 
		(the gradient on the sidebar of this page is obviously stretched, 
		the shadow on this on the content is stretched as well, but repeating it would produce the same result),
		this image may be strecthed by level instead of gradually, particulary .
	</p>-->
	<h3>Creating multi-state buttons</h3>
	<p>
		Browsers supporting border-image natively could be asked to slice a different
		image for each state of the button:
	</p>
<pre><code>    .button a {
        -moz-border-image: url("media/button0.png") 0 5;
        -webkit-border-image: url("media/button0.png") 0 5;
    }
    .button a:hover {
        -moz-border-image: url("media/button1.png") 0 5;
        -webkit-border-image: url("media/butto1.png") 0 5;
    }	
    .button a:focus {
        -moz-border-image: url("media/button2.png") 0 5;
        -webkit-border-image: url("media/button2.png") 0 5;
    }</code></pre>
	<p>
		But in browsers emulating border-image, performance is an issue for this kind of operation,
		buttons would flicker each time their state changed if using this kind of code:
	</p>
<pre><code>$('.button a').borderImage('url("media/button0.png") 0 5')
    .mouseover('url("media/button1.png") 0 5')
    .focus('url("media/button2.png") 0 5');
</code></pre>
	<p>
		It is more efficient to slice the different images for each state once,
		and display only slices corresponding to the current state of the button.
		jquery.borderImage.js provides a way to slice, in the same way, different images for a single element:
	</p>
<pre><code>$('.button a').borderImage(
    'url("media/button0.png") 0 5,
    'media/button1.png',
    'media/button2.png'
);</code></pre>
	<span class="center"><i>Slices from each image will be </i>tagged<i> with a different class</i> (image0, image1, ...)</span>
	<p>
		But borderImage isn't aware what image corresponds to what event.
		A hybrid JavaScript/css solution has to be used for that purpose.
		Note that browsers with native implementation have to be handled separately in CSS when using the <i>alternative image syntax</i>. 
	</p>
<pre><code>&lt;script&gt;
    $('.button a').borderImage(
		// Slices from this image will be tagged with class 'image0'
        'url("media/button0.png") 0 5',
        // Then specify as much alternative image as needed.
        // Just add any number of image's URL as String parameter.
        'media/button1.png', // Tagged 'image1'
        'media/button2.png' // Tagged 'image2'
    // The most performant solution is to switch class of the button on an event,
    // and then let css switch display of the slices.
    ).mouseover(function(){
        $(this).addClass('bi1')
    }).mouseout(function(){
        $(this).removeClass('bi1')
    }).focus(function(){
        $(this).addClass('bi2')
    }).blur(function(){
        $(this).removeClass('bi2')
    });
&lt;/script&gt;

&lt;style&gt;
    .button a {
        border: solid transparent;
        border-width: 0 8px;
    }		
    .button a:focus {
        outline: none;
    }
    /* All slices are hidden under the button by default */
    .button a .biSlice {
        z-index: -1;
    }
    /* Only slices from the first image are visible */
    .button a .image0 {
        z-index: 0;
    }
    /* browsers using native implementation are handled with css */ 
    .button a {
        -moz-border-image: url("media/button0.png") 0 5;
        -webkit-border-image: url("media/button0.png") 0 5;
    }
    /* When class of a button is switched, the alternative images are made visible */
    .button a.bi1 .image1 {
        z-index:e 0;
    }
    /* Same effect but for browsers using native implementation */
    .button a.bi1 {
        -moz-border-image: url("media/button1.png") 0 5;
        -webkit-border-image: url("media/butto1.png") 0 5;
    }
    .button a.bi2 .image2 {
        z-index: 0;
    }
    .button a.bi2 {
        -moz-border-image: url("media/button2.png") 0 5;
        -webkit-border-image: url("media/button2.png") 0 5;
    }
&lt;style&gt;
</code></pre>
</div>
<div class="tab" id="images">Blah</div>
<div class="tab" id="advanced">Blah blah</div>
</div>
	<script type="text/javascript" src="jquery-1.3.2.js"></script>
	<script type="text/javascript" src="demonstration.js"></script>
	<script type="text/javascript" src="../jquery.borderImage.js"></script>
	<script type="text/javascript">
		$(document).ready(function(){
			// Page layout
			$('#sidebar').borderImage('url("media/gradient.png") 10 10 0', 100);			
			$('#main').borderImage('url("media/betterShadow.png") 8');
			
			$('#nav li').borderImage('url("media/gradtab2.png") 6 6 0', 'media/gradtab1.png' );
			
			$('.tab:gt(0)').hide();
			
			// Interactive demonstration
			$('#innaccessible, #demonstration').css('display', 'inline');
			backToOrigin();
			var $demo = $('#demonstration').find('select').change(function(){
				switchStretch();
			});
			
			// Technical demonstrations
			$('code.demo').each(function(i, el){
				var $el = $(el),
					$prev = $el.parent().parent().prev('div'),
					result0 = /:\s*(.*?)\s*;/.exec($el.text()),
					result1 = /:\s*([\d px]*)\s*;/.exec($prev.find('code').text()),
					style = {
						border: 'solid transparent',
						borderWidth: result1[1]
					};
				if(result0[1] && result1[1]) {
					$prev.find(':first').css(style);
					setTimeout(function(){
						$prev.find(':first').borderImage(result0[1]);
					}, 200);
				}				
			});
			
			$('#nav').click(function(e) {
				var target = e.target;
				if(target.nodeName != 'UL') {
					while(target.nodeName != 'LI')
						target = target.parentNode;
					if(target.className != 'selected') {						
						$(this).find('li').removeClass('selected');
						$('.tab').hide();
						$($(target).addClass('selected').find('a').attr('href')).show();
					}
				}
			});
			
			$('#buttons a, .button a').borderImage('url("media/button0.png") 0 5', 'media/button1.png', 'media/button2.png')
			.mouseover(function(){
				$(this).addClass('bi1')
			}).mouseout(function(){
				$(this).removeClass('bi1')
			}).focus(function(){
				$(this).addClass('bi2')
			}).blur(function(){
				$(this).removeClass('bi2')
			});
		});
	</script>
</body>
</html>